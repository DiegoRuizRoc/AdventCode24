#include <iostream>
#include <vector>
#include <fstream>
#include <cmath>
#include <queue>
#include <unordered_map>
#include <sstream>

constexpr int n_level = 25; // Número máximo de parpadeos

struct TreeNode {
    long long engraving; //Numero grabado en la piedra
    TreeNode* left; //Apunta al hijo izquierdo
    TreeNode* right; //Apunta al hijo derecho

    TreeNode(long long engraving) : engraving(engraving), left(nullptr), right(nullptr) {}
};

// Función para calcular el número de dígitos de un número
int count_digits(long long number) {
    return number == 0 ? 1 : static_cast<int>(std::log10(number)) + 1;
}

// Construir un árbol desde un nodo raíz
void build_tree(TreeNode* node, int level, int max_level) {
    if (level >= max_level) return;

    int n_digits = count_digits(node->engraving);

    if (node->engraving == 0) {
        node->left = new TreeNode(1);
        build_tree(node->left, level + 1, max_level);
    } else if (n_digits % 2 == 0) {
        long long power = static_cast<long long>(std::pow(10, n_digits / 2));
        long long left_value = node->engraving / power;
        long long right_value = node->engraving % power;

        node->left = new TreeNode(left_value);
        node->right = new TreeNode(right_value);

        build_tree(node->left, level + 1, max_level);
        build_tree(node->right, level + 1, max_level);
    } else {
        node->left = new TreeNode(node->engraving * 2024);
        build_tree(node->left, level + 1, max_level);
    }
}

// Contar las piedras en el árbol después de n_level parpadeos
long long count_stones(TreeNode* node, int level) {
    if (level == n_level) return 1;

    long long total = 0;
    if (node->left) total += count_stones(node->left, level + 1);
    if (node->right) total += count_stones(node->right, level + 1);

    return total;
}

// Liberar la memoria del árbol
void delete_tree(TreeNode* node) {
    if (!node) return;

    delete_tree(node->left);
    delete_tree(node->right);
    delete node;
}

int main() {
    std::ifstream file("input.txt");
    if (!file) {
        std::cerr << "Error al abrir el archivo input.txt\n";
        return 1;
    }

    std::vector<long long> stones;
    std::string line;
    while (std::getline(file, line)) {
        std::istringstream iss(line);
        std::string token;

        while (iss >> token) {
            try {
                stones.push_back(std::stoll(token));
            } catch (const std::invalid_argument& e) {
                std::cerr << "Advertencia: Entrada inválida encontrada, ignorando: " << token << '\n';
            } catch (const std::out_of_range& e) {
                std::cerr << "Advertencia: Número fuera de rango encontrado, ignorando: " << token << '\n';
            }
        }
    }

    long long total_stones = 0;

    // Procesar cada piedra de entrada
    for (long long stone : stones) {
        TreeNode* root = new TreeNode(stone);
        build_tree(root, 0, n_level);
        total_stones += count_stones(root, 0);
        delete_tree(root); // Limpiar la memoria del árbol
    }

    std::cout << "Total de piedras después de " << n_level << " parpadeos: " << total_stones << '\n';

    return 0;
}
